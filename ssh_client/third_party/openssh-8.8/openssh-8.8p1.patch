We hack the agent code to use a fake IP address which the plugin watches for.
We should have the plugin deal with AF_UNIX requests instead, then we won't
have to hack up OpenSSH.

--- a/authfd.c
+++ b/authfd.c
@@ -90,13 +90,16 @@
 ssh_get_authentication_socket_path(const char *authsocket, int *fdp)
 {
 	int sock, oerrno;
-	struct sockaddr_un sunaddr;
+	struct sockaddr_in sunaddr;
+
+	/* Magic value. Keep in sync with //ssh_client/src/file_system.cc */
+	static const int kSshAgentFakeIP = 0x7F010203;
 
 	memset(&sunaddr, 0, sizeof(sunaddr));
-	sunaddr.sun_family = AF_UNIX;
-	strlcpy(sunaddr.sun_path, authsocket, sizeof(sunaddr.sun_path));
+	sunaddr.sin_family = AF_INET;
+	sunaddr.sin_addr.s_addr = htonl(kSshAgentFakeIP);
 
-	if ((sock = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
+	if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
 		return SSH_ERR_SYSTEM_ERROR;
 
 	/* close on exec */

https://crbug.com/1312256
https://github.com/WebAssembly/wasi-libc/issues/283

Do not assume internal fd_set implementation details.  Just allocate the full
structure once and call it a day.  NaCl (glibc/newlib)'s fd_set happen to be
implemented the way OpenSSH assumes, but WASI libc's is not which causes memory
errors when building for that.

OpenSSH-8.9+ doesn't have this problem because it replaced all of the select()
code with poll() which doesn't manage fd_set's like this.

--- a/channels.c
+++ b/channels.c
@@ -2465,25 +2465,20 @@
 channel_prepare_select(struct ssh *ssh, fd_set **readsetp, fd_set **writesetp,
     int *maxfdp, u_int *nallocp, time_t *minwait_secs)
 {
-	u_int n, sz, nfdset;
+	u_int sz;
 
 	channel_before_prepare_select(ssh); /* might update channel_max_fd */
 
-	n = MAXIMUM(*maxfdp, ssh->chanctxt->channel_max_fd);
-
-	nfdset = howmany(n+1, NFDBITS);
-	/* Explicitly test here, because xrealloc isn't always called */
-	if (nfdset && SIZE_MAX / nfdset < sizeof(fd_mask))
-		fatal("channel_prepare_select: max_fd (%d) is too large", n);
-	sz = nfdset * sizeof(fd_mask);
-
-	/* perhaps check sz < nalloc/2 and shrink? */
-	if (*readsetp == NULL || sz > *nallocp) {
-		*readsetp = xreallocarray(*readsetp, nfdset, sizeof(fd_mask));
-		*writesetp = xreallocarray(*writesetp, nfdset, sizeof(fd_mask));
+	sz = sizeof(fd_set);
+	if (*readsetp == NULL) {
+		*readsetp = malloc(sz);
+		*writesetp = malloc(sz);
 		*nallocp = sz;
 	}
-	*maxfdp = n;
+
+	*maxfdp = MAXIMUM(*maxfdp, ssh->chanctxt->channel_max_fd);
+	if (*maxfdp >= FD_SETSIZE)
+		fatal("channel_prepare_select: max_fd (%d) is too large for FD_SETSIZE (%d)", *maxfdp, FD_SETSIZE);
 	memset(*readsetp, 0, sz);
 	memset(*writesetp, 0, sz);
 
