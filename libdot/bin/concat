#!/usr/bin/env python3
# Copyright 2018 The ChromiumOS Authors
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

r"""Concatenate a list of files into a single file.

The list of files to concat is supplied via a text file using the --input-from
option.  All filenames in that list are treated relative to the list file
itself.  Absolute paths also work, but should be avoided when the input file is
intended to be used by others.

Long lines may be wrapped using the standard \ notation.

There are a few directives that can be specified in the input file.  They are...

@file FILE

  Include the specified file verbatim in the output.  The file is relative to
  the input file.  For convenience, the @file may be omitted.

@include FILE

  This can be used to include an additional list of files.  It's useful when
  you want to include a list of files specified by a separate project, or
  any time you want to compose lists of dependencies.

  If an included file specifies a file that is already part of the result it
  will not be duplicated.

  When an included file is being processed this script will change the current
  directory to the directory where the FILE was found.  This is to make certain
  that any scripts executed by an included @resource directive happen relative
  to a known location.
"""

import argparse
import logging
import os
from pathlib import Path
import sys

import libdot


def echo_results(output_to, data, header_files, es_module):
    """Write |data| to |output_to| or stdout."""
    header = (
        "// This file was generated by libdot/bin/concat.\n"
        "// It has been marked read-only for your safety.  Rather than\n"
        "// edit it directly, please modify one of these source files.\n"
        "//\n"
    )
    for f in header_files:
        header += f"// {f}\n"

    # Insert the strict directive for the whole file.
    if not es_module:
        header += "\n'use strict';\n"

    data = header + "\n" + data

    if not output_to:
        print(data)
    else:
        libdot.unlink(output_to)
        with open(output_to, "w", encoding="utf-8") as f:
            f.write(data)


def process_concat_line(line, seen_files, header_files):
    """Process a single line from a concat file."""
    ret = ""

    # If the input line doesn't start with an "@", it's just a file to include
    # in the output.
    if not line.startswith("@"):
        line = "@file " + line

    logging.info(line)

    mode, arg = line.split(" ", 1)
    if mode == "@file":
        path = (libdot.LIBAPPS_DIR / arg).resolve()
        if path in seen_files:
            return ""
        seen_files.add(path)
        header_files.append(arg)

        ret += f"// SOURCE FILE: {arg}\n"
        with path.open(encoding="utf-8") as f:
            lines = f.readlines()

            # Strip out the 'use strict' directive as we add it ourselves and
            # a lot of tools get confused when it shows up more than once.
            try:
                i = lines[0:50].index("'use strict';\n")
                lines.pop(i)
                while lines[i] == "\n":
                    lines.pop(i)
            except ValueError:
                pass

            ret += "".join(lines)

        # Make sure we always emit a trailing newline even if the input didn't.
        ret = ret.rstrip() + "\n"

    else:
        raise ValueError(f"Unknown directive: {line}")

    return ret


def process_concat_file(path, seen_files, header_files):
    """Process a concat file specified by absolute path."""
    oldwd = Path.cwd()
    os.chdir(path.resolve().parent)

    ret = ""

    with path.open(encoding="utf-8") as f:
        lines = f.readlines()
        i = 0
        while i < len(lines):
            line = lines[i].strip()

            # Handle trailing escape as line continuation.
            while line.endswith("\\"):
                # Strip trailing escape.
                line = line[:-1]
                i += 1
                line += lines[i].strip()

            if not line or line.startswith("#"):
                # Skip blank lines and comments.
                i += 1
                continue

            if line.startswith("@include "):
                _, inc_path = line.split(" ", 1)
                logging.info(inc_path)
                inc_path = libdot.LIBAPPS_DIR / inc_path
                ret += process_concat_file(inc_path, seen_files, header_files)
            else:
                ret += process_concat_line(line, seen_files, header_files)

            i += 1

    os.chdir(oldwd)
    return ret


def concat(input_file, output_file, es_module=False):
    """Process the concat |input_file| and write the result to |output_file|."""
    logging.info("Creating %s", output_file)

    # List of files we've included in the output to be included in the header of
    # the output.  These paths should be as specified in the concat source list
    # so they're short and relative to the LIBDOT_SEARCH_PATH.
    header_files = []

    # Files that we've seen but don't want to process more than once.
    seen_files = set()

    data = process_concat_file(input_file, seen_files, header_files)
    echo_results(output_file, data, header_files, es_module)


def get_parser():
    """Get a command line parser."""
    parser = libdot.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    parser.add_argument(
        "-i",
        "--input-from",
        required=True,
        type=Path,
        help="File containing a list of files to concatenate.",
    )
    parser.add_argument(
        "--es-module",
        type=bool,
        default=False,
        help="Output will be an ES module.",
    )
    parser.add_argument("-o", "--output", type=Path, help="The output file.")
    return parser


def main(argv):
    """The main func!"""
    parser = get_parser()
    opts = parser.parse_args(argv)

    input_from = opts.input_from.resolve()
    output_to = opts.output.resolve()
    concat(input_from, output_to, es_module=opts.es_module)


if __name__ == "__main__":
    sys.exit(main(sys.argv[1:]))
