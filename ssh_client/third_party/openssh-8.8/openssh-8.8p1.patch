--- a/ssh.c
+++ b/ssh.c
@@ -631,7 +631,12 @@ ssh_conn_info_free(struct ssh_conn_info *cinfo)
  * Main program for the ssh client.
  */
 int
+#if defined(__pnacl__) || defined(__nacl__)
+ssh_main(int ac, char **av, const char *subsystem)
+#else
+#define subsystem NULL
 main(int ac, char **av)
+#endif
 {
 	struct ssh *ssh = NULL;
 	int i, r, opt, exit_status, use_syslog, direct, timeout_ms;
@@ -1113,6 +1118,21 @@ main(int ac, char **av)
 	if ((command = sshbuf_new()) == NULL)
 		fatal("sshbuf_new failed");
 
+	if (subsystem) {
+		/*
+		 * Hijack the codeflow now that we're done parsing the command line.
+		 * We want all the flags, but none of the command line.  Unless they
+		 * passed in -s themselves.
+		 */
+		if (options.session_type == -1) {
+			options.session_type = SESSION_TYPE_SUBSYSTEM;
+			av = xcalloc(2, sizeof(*av));
+			av[0] = subsystem;
+			av[1] = NULL;
+			ac = 1;
+		}
+	}
+
 	/*
 	 * Save the command to execute on the remote host in a buffer. There
 	 * is no limit on the length of the command, except by the maximum

We hack the agent code to use a fake IP address which the plugin watches for.
We should have the plugin deal with AF_UNIX requests instead, then we won't
have to hack up OpenSSH.

--- a/authfd.c
+++ b/authfd.c
@@ -90,13 +90,16 @@
 ssh_get_authentication_socket_path(const char *authsocket, int *fdp)
 {
 	int sock, oerrno;
-	struct sockaddr_un sunaddr;
+	struct sockaddr_in sunaddr;
+
+	/* Magic value. Keep in sync with //ssh_client/src/file_system.cc */
+	static const int kSshAgentFakeIP = 0x7F010203;
 
 	memset(&sunaddr, 0, sizeof(sunaddr));
-	sunaddr.sun_family = AF_UNIX;
-	strlcpy(sunaddr.sun_path, authsocket, sizeof(sunaddr.sun_path));
+	sunaddr.sin_family = AF_INET;
+	sunaddr.sin_addr.s_addr = htonl(kSshAgentFakeIP);
 
-	if ((sock = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
+	if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
 		return SSH_ERR_SYSTEM_ERROR;
 
 	/* close on exec */

the bind_permitted() check doesn't work well in the nacl env.  leave it to the
host os to do the actual check and deny/permit as makes sense.

daemonized() relies on funcs we don't implement (because we don't need them),
and this func is only used in sshd.  disable it to avoid link failures.

subprocess() relies on execv funcs we don't implement.

--- a/misc.c
+++ b/misc.c
@@ -1894,6 +1894,7 @@ forward_equals(const struct Forward *a, const struct Forward *b)
 	return 1;
 }
 
+#if !defined(__pnacl__) && !defined(__nacl__)
 /* returns 1 if process is already daemonized, 0 otherwise */
 int
 daemonized(void)
@@ -1911,6 +1912,7 @@ daemonized(void)
 	debug3("already daemonized");
 	return 1;
 }
+#endif
 
 
 /*
@@ -2465,6 +2467,9 @@ opt_array_append(const char *file, const int line, const char *directive,
 	opt_array_append2(file, line, directive, array, NULL, lp, s, 0);
 }
 
+#ifndef SA_RESTART
+#define SA_RESTART 0
+#endif
 sshsig_t
 ssh_signal(int signum, sshsig_t handler)
 {
@@ -2645,10 +2650,12 @@ subprocess(const char *tag, const char *command,
 			error("%s: dup2: %s", tag, strerror(errno));
 			_exit(1);
 		}
+#if !defined(__pnacl__) && !defined(__nacl__)
 		if (env != NULL)
 			execve(av[0], av, env);
 		else
 			execv(av[0], av);
+#endif
 		error("%s %s \"%s\": %s", tag, env == NULL ? "execv" : "execve",
 		    command, strerror(errno));
 		_exit(127);

The pnacl toolchain doesn't provide realpath(), but does define the prototype.
This messes up the local replacement logic.

--- a/sftp-realpath.c
+++ b/sftp-realpath.c
@@ -27,6 +27,8 @@
  * SUCH DAMAGE.
  */
 
+#define HAVE_REALPATH 1
+
 #include "includes.h"
 
 #include <sys/types.h>

These statvfs defines might not exist.

--- a/sftp-client.c
+++ b/sftp-client.c
@@ -384,8 +384,13 @@ get_decode_statvfs(struct sftp_conn *conn, struct sftp_statvfs *st,
 	    (r = sshbuf_get_u64(msg, &st->f_namemax)) != 0)
 		fatal_fr(r, "parse statvfs");
 
+	st->f_flag = 0;
+#ifdef ST_RDONLY
 	st->f_flag = (flag & SSH2_FXE_STATVFS_ST_RDONLY) ? ST_RDONLY : 0;
+#endif
+#ifdef ST_NOSUID
 	st->f_flag |= (flag & SSH2_FXE_STATVFS_ST_NOSUID) ? ST_NOSUID : 0;
+#endif
 
 	sshbuf_free(msg);
 

The pnacl toolchain lacks these standard defines.

--- a/openbsd-compat/glob.c
+++ b/openbsd-compat/glob.c
@@ -87,6 +87,10 @@
 # undef TILDE
 #endif
 
+#ifndef SSIZE_MAX
+#define SSIZE_MAX INT_MAX
+#endif
+
 #define	DOLLAR		'$'
 #define	DOT		'.'
 #define	EOS		'\0'

https://crbug.com/1208926
Our NaCl filesystem emulation is too simple to support the hostkey update logic.
We stub out stat() & unlink() which makes it fail.  Turn the default back off in
the newer releases.

--- a/readconf.c
+++ b/readconf.c
@@ -2392,12 +2392,14 @@
 		    xstrdup(_PATH_SSH_SYSTEM_HOSTFILE2);
 	}
 	if (options->update_hostkeys == -1) {
+#if !defined(__pnacl__) && !defined(__nacl__)
 		if (options->verify_host_key_dns <= 0 &&
 		    (options->num_user_hostfiles == 0 ||
 		    (options->num_user_hostfiles == 1 && strcmp(options->
 		    user_hostfiles[0], _PATH_SSH_USER_HOSTFILE) == 0)))
 			options->update_hostkeys = SSH_UPDATE_HOSTKEYS_YES;
 		else
+#endif
 			options->update_hostkeys = SSH_UPDATE_HOSTKEYS_NO;
 	}
 	if (options->num_user_hostfiles == 0) {

The WASI system requires us to pass in a bunch of open file descriptors for
access to file system paths.  If we close them, then we're shut off from the
entire file system.  Plus, we know that we aren't leaking random fd's into the
process that ssh has to protect itself from.  So remove this initial call.
https://crbug.com/1312165

--- a/ssh.c
+++ b/ssh.c
@@ -640,12 +640,6 @@
 	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
 	sanitise_stdfd();
 
-	/*
-	 * Discard other fds that are hanging around. These can cause problem
-	 * with backgrounded ssh processes started by ControlPersist.
-	 */
-	closefrom(STDERR_FILENO + 1);
-
 	__progname = ssh_get_progname(av[0]);
 
 #ifndef HAVE_SETPROCTITLE

https://crbug.com/1312256
https://github.com/WebAssembly/wasi-libc/issues/283

Do not assume internal fd_set implementation details.  Just allocate the full
structure once and call it a day.  NaCl (glibc/newlib)'s fd_set happen to be
implemented the way OpenSSH assumes, but WASI libc's is not which causes memory
errors when building for that.

OpenSSH-8.9+ doesn't have this problem because it replaced all of the select()
code with poll() which doesn't manage fd_set's like this.

--- a/channels.c
+++ b/channels.c
@@ -2465,25 +2465,20 @@
 channel_prepare_select(struct ssh *ssh, fd_set **readsetp, fd_set **writesetp,
     int *maxfdp, u_int *nallocp, time_t *minwait_secs)
 {
-	u_int n, sz, nfdset;
+	u_int sz;
 
 	channel_before_prepare_select(ssh); /* might update channel_max_fd */
 
-	n = MAXIMUM(*maxfdp, ssh->chanctxt->channel_max_fd);
-
-	nfdset = howmany(n+1, NFDBITS);
-	/* Explicitly test here, because xrealloc isn't always called */
-	if (nfdset && SIZE_MAX / nfdset < sizeof(fd_mask))
-		fatal("channel_prepare_select: max_fd (%d) is too large", n);
-	sz = nfdset * sizeof(fd_mask);
-
-	/* perhaps check sz < nalloc/2 and shrink? */
-	if (*readsetp == NULL || sz > *nallocp) {
-		*readsetp = xreallocarray(*readsetp, nfdset, sizeof(fd_mask));
-		*writesetp = xreallocarray(*writesetp, nfdset, sizeof(fd_mask));
+	sz = sizeof(fd_set);
+	if (*readsetp == NULL) {
+		*readsetp = malloc(sz);
+		*writesetp = malloc(sz);
 		*nallocp = sz;
 	}
-	*maxfdp = n;
+
+	*maxfdp = MAXIMUM(*maxfdp, ssh->chanctxt->channel_max_fd);
+	if (*maxfdp >= FD_SETSIZE)
+		fatal("channel_prepare_select: max_fd (%d) is too large for FD_SETSIZE (%d)", *maxfdp, FD_SETSIZE);
 	memset(*readsetp, 0, sz);
 	memset(*writesetp, 0, sz);
 
